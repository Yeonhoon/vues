# 1. vuetify에서 layout 순서:
v-container > v-layout > v-flex

# 2. 부모 컴포넌트에서 자식컴포넌트로 데이터를 보내는 경우,
- 부모 자식 컴포넌트간 데이터 송수신을 위해서는 부모 컴포넌트에 자식 컴포넌트가 호출되어 있어야.
- 자식 컴포넌트에서 $emit을 통해 부모에게 데이터를 보냄
- 부모 컴포넌트에서는 @~ : "~"를 통해 자식이 보낸 데이터를 받음
- 자식 컴포넌트에서 props를 통해 데이터를 받음.
- 받은 데이터를 따로 this~.하는 것이 아니라 template에서 바로 사용함.





# 자식 컴포넌트 간 데이터를 보내는 경우: eventBus
- main.js에서 eventBus를 생성함
export const eventBus = new Vue({
  methods:{
    editTodo(memo){
      this.$emit(memo)
    }
  }
})

- 보내는 자식 컴포넌트, 받는 자식 컴포넌트 모두 eventBus를 import함
  import {eventBus} from '../main'

- 보내는 자식 컴포넌트에서는 @click = editTodo(this.memo, key)
methods:{
  eventBus.editTodo()
}

- 받는 자식 컴포넌트에서는 eventBus를 듣고 있어야함
  - created() {
    eventBus.$on(editTodo, (memo, key)=>{
      this.memo = memo
      this.key = key
    })  
  }
  - 받은 값을 반영하기 위해 data()에 미리 초기값을 선언해둠
  data(){
    returns{
      memo: null,
      key: null
    }
  }


# vue Router
- App에서 <router-view></router-view>가 선언되어 있어야함.
- lazy-load: vuejs는 spa이기 때문에 전체 컴포넌트를 시작할 때 불러와야함
  - 그럴 경우 처음 페이지를 불러올 때 오래 걸림.
  - lazy load로 설정할 경우 그 페이지는 주소창에 호출이 됐을 때, 그것만 보여줌.

- 방식1: 컴포넌트에서  @click="$router.push({name:'About'})" 을 통해 router에서 미리 선언한 값으로 routing
- 방식2: <router-link></router-link> 내부에서 router :to='{}' 형태의 객체.
- .push()안에 {}객체가 아닌 path를 입력할 수 있음.
  - 그러나 어떤 컴포넌트를 가리키는 건지 모를 수 있음.
  - 보통 페이지를 넘길 때, 객체 안에 넘길 값을 포함하기 때문에 객체 방식이 더 많이 쓰임.

- route 경로가 정확히 일치할 때만 버튼이 활성화되게끔 보이려면 'exact' 사용

- history mode:
  - router의 default: hash 모드

- parameter

  - router와 route의 차이
    - router는 router.js에서 선언한 Router에 관련된 정보
    - route는 현재 주소에서 넘어온 값과 관련된 객체
  - parameter를 넘기기 위해서 꼭 router.js에 :~형식으로 할 필요는 없음.
  - router-link 가 있는 곳에서 params객체를 이용해 parameter를 넘겨줄 수 있음.

- query
  - params와 동일하게 app의 <router-link></router-link> 내부에서 사용함.
  - parameter와 다르게 query는 주소창에 입력값이 다 노출됨.
  - 페이지나 데이터의 보안에 따라 param 이나 query를 선택해야 함.

- Children
  - 하위경로 e.g. ~a/bb
  - router.js 파일에 Children: [
    {
      paths, names, components를 미리 설정함
    }
  ]
  - 하위 경로 페이지를 호출하는 페이지에서 이벤트발생에 따른 하위경로 호출
    - e.g. 버튼 클릭 시 새로운 페이지 호출
      - @click="call()" 함수로 설정
      - script 부분에서 this.$router.push({
          name:~
          params: {
            id:
          }
      }) 등 router.js에서 설정한 값대로 입력해줌.
    - 하위경로에서는 computed를 통해 값이 변경되었을 때, return을 통해 변경된 값을 가져옴


# Vuex
부모 자식 간 통신을 관리하는 중앙관리소
- main.js에서 import store from './store.js'로 먼저 불러놓음
- store.js에는 저장할 데이터를 입력해둠.
- 저장할 데이터를 사용하기 위해서는 $store.~.~ 형식으로 입력하여 store.js를 바라보게 할 것.
- getters
  - component명을 중복호출하는 것을 방지.
  - vue instance의 computed와 동일한 역할
  - computed와의 차이점: 
    - computed는 this.~를 통해 사용해야했음.
    - getters는 사용할 파일을 함수의 파라미터로 
  - store.getters.~로 사용
- mapgetters: '$store.getters' 문구가 반복사용되는 것을 막음
  - vuex에서 가져오기 때문에 import {mapGetters} from 'vuex'로 불러와야함.
  - computed에서 사용
    -...mapGetters(['getters이름','',''])
  - mapGetters에서 선언한 getters는 template에서 $store.getters 없이도 사용 가능
  - 마치 computed에서 일일이 불러오는 것처럼 사용 가능.
- mapstate도 사용 가능함.
    
 
# Mutation
  - mutation이 필요한 이유: 
    - component에서 함수를 통해 변화되는 값이 state를 통해 저장됨.
    - component들에서 state로 값을 보내기 위해서는 컴포넌트별로 함수가 선언되어있어야 함.
    - 이렇게 모든 컴포넌트에서 선언되는 값을 mutation에 미리 선언한 뒤 불러오기만 함으로써 효율적으로 관리.